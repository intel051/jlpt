<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HSK 단어 학습 & 퀴즈 앱 (Firebase)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    <script src="https://www.gstatic.com/firebasejs/9/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9/firebase-firestore-compat.js"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'toss-blue': '#3B82F6',
                        'toss-green': '#22C55E', 
                        'toss-yellow': '#FFD34C', 
                        'hsk-red': '#E53E3E', 
                    },
                },
            },
        };
    </script>

    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
        
        :root {
            --font-pretendard: 'Pretendard', 'Inter', sans-serif;
        }

        body {
            font-family: var(--font-pretendard);
        }

        /* 기타 스타일 유지 */
        .level-button { transition: all 0.2s; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
        .level-button.active { transform: translateY(-2px); box-shadow: 0 10px 15px -3px rgba(229, 62, 62, 0.3); } 
        .word-cell-simplified { min-width: 80px; }
        .tab-button { transition: all 0.2s; border-top-left-radius: 0.75rem; border-top-right-radius: 0.75rem; }
        .tab-button.active { border-bottom: 3px solid #3B82F6; color: #3B82F6; font-weight: 600; background-color: white !important; }
        .answer-button { transition: all 0.2s; }
        .answer-button:hover { transform: translateY(-1px); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
    </style>
    
    <script type="module">
        // ------------------------------------------
        // 🔥 1. FIREBASE 설정 및 초기화
        // ------------------------------------------
        const firebaseConfig = {
            apiKey: "AIzaSyB8nw2LEuAl3q375a-IWfT5sSU48I2dukg",
            authDomain: "jlpt-9f958.firebaseapp.com",
            projectId: "jlpt-9f958",
            storageBucket: "jlpt-9f958.firebasestorage.app",
            messagingSenderId: "1088397251559",
            appId: "1:1088397251559:web:bdd8d0769f81b47a7d2342",
            measurementId: "G-P2D5HQ94S2"
        };
        
        // Firebase 초기화 (initializeApp, getAnalytics는 V9 Module 방식이며, 
        // 호환성 SDK를 사용하므로 firebase.initializeApp 방식으로 변경)
        const app = firebase.initializeApp(firebaseConfig);
        const auth = app.auth(); // 인증 모듈
        const db = app.firestore(); // Firestore 모듈
        // const analytics = firebase.analytics(); // Analytics는 생략 (CDN을 모두 추가해야 함)

        // Gemini API Configuration
        const API_KEY = "AIzaSyDfpal-sPS5EeCLYrvmeVnc_sA69L_EQ8M"; 
        const API_URL_BASE = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent";
        const MAX_RETRIES = 3;
        const INITIAL_BACKOFF_MS = 1000;

        // ------------------------------------------
        // 🚀 2. Application State (FIREBASE 맞춤 변경)
        // ------------------------------------------
        let userId = null; // 로컬 스토리지 deviceId 대신 사용
        let isAppReady = false;
        let selectedLevel = 3; 
        let currentView = 'generator'; 
        let generatedWords = [];
        let savedWordLists = []; 
        let wordFolders = []; 
        let selectedFolderId = null; 
        let quizWords = [];
        let currentQuestionIndex = 0;
        let quizScore = 0;
        let quizOptions = [];
        let stats = { totalAttempts: 0, totalCorrect: 0, overallRate: 0 };
        let wrongWords = []; 
        let manualSavedWords = []; 
        let isViewingWrongWords = false; 

        // UI Elements
        const appContainer = document.getElementById('app');
        const contentContainer = document.getElementById('content-container');
        const levelSelector = document.getElementById('level-selector');
        const listTitle = document.getElementById('list-title');
        const errorMessageDiv = document.getElementById('error-message');
        const tabGenerator = document.getElementById('tab-generator');
        const tabLists = document.getElementById('tab-lists');

        // --- Core Utility: Safe Unique ID Generator ---
        function generateUniqueId() {
            if (window.crypto && window.crypto.randomUUID) {
                return window.crypto.randomUUID();
            }
            return Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
        }

        // ------------------------------------------
        // 💾 3. FIREBASE 데이터 저장/로드 함수 (로컬 스토리지 대체)
        // ------------------------------------------

        // 모든 데이터 로드 (초기 1회)
        async function loadUserDataFromFirestore() {
            if (!userId) return;

            try {
                // 1. 통계 로드
                const statsDoc = await db.collection('users').doc(userId).get();
                if (statsDoc.exists) {
                    const data = statsDoc.data();
                    stats.totalAttempts = data.totalAttempts || 0;
                    stats.totalCorrect = data.totalCorrect || 0;
                    if (stats.totalAttempts > 0) {
                        stats.overallRate = Math.round((stats.totalCorrect / stats.totalAttempts) * 100);
                    } else {
                        stats.overallRate = 0;
                    }
                } else {
                    await db.collection('users').doc(userId).set({ totalAttempts: 0, totalCorrect: 0 });
                }

                // 2. 폴더, 단어 목록, 개별 단어, 오답 노트 로드
                const [foldersSnapshot, listsSnapshot, manualSnapshot, wrongSnapshot] = await Promise.all([
                    db.collection('users').doc(userId).collection('folders').get(),
                    db.collection('users').doc(userId).collection('lists').get(),
                    db.collection('users').doc(userId).collection('manualWords').get(),
                    db.collection('users').doc(userId).collection('wrongWords').get()
                ]);

                wordFolders = foldersSnapshot.docs.map(doc => doc.data());
                savedWordLists = listsSnapshot.docs.map(doc => doc.data());
                manualSavedWords = manualSnapshot.docs.map(doc => doc.data());
                wrongWords = wrongSnapshot.docs.map(doc => doc.data());

                // 기본 폴더 처리 (로컬 스토리지와 동일하게)
                if (wordFolders.length === 0) {
                    const defaultFolderId = generateUniqueId(); 
                    wordFolders.push({ id: defaultFolderId, name: '전체 단어장', createdAt: new Date().toISOString() });
                    await db.collection('users').doc(userId).collection('folders').doc(defaultFolderId).set(wordFolders[0]);
                } 
                if (!selectedFolderId) {
                    selectedFolderId = wordFolders[0].id;
                }
                
                isAppReady = true;
                renderApp();

            } catch (e) {
                console.error("Firebase 데이터 로드 오류:", e);
                showError("데이터를 불러오는 데 실패했습니다. 연결 상태를 확인해 주세요.");
                isAppReady = true;
                renderApp(); // 오류 상태로라도 앱 렌더링
            }
        }
        
        // 통계 업데이트
        async function updateStats(attempts, correct) {
            if (!userId) return;

            // Firestore FieldValue.increment 사용
            const userRef = db.collection('users').doc(userId);

            try {
                await userRef.set({
                    totalAttempts: firebase.firestore.FieldValue.increment(attempts),
                    totalCorrect: firebase.firestore.FieldValue.increment(correct),
                }, { merge: true }); // 기존 필드 유지하며 업데이트
                
                // 로컬 상태 업데이트
                stats.totalAttempts += attempts;
                stats.totalCorrect += correct;
                if (stats.totalAttempts > 0) {
                    stats.overallRate = Math.round((stats.totalCorrect / stats.totalAttempts) * 100);
                } else {
                    stats.overallRate = 0;
                }

            } catch (error) {
                console.error("통계 업데이트 오류:", error);
            }
        }

        // 폴더 저장
        async function saveFolderToFirestore(folder) {
            if (!userId) return;
            try {
                await db.collection('users').doc(userId).collection('folders').doc(folder.id).set(folder);
            } catch (e) {
                console.error("폴더 저장 오류:", e);
                showError("폴더 저장에 실패했습니다.");
            }
        }
        
        // 폴더 삭제
        async function deleteFolderFromFirestore(folderId) {
            if (!userId) return;
            try {
                await db.collection('users').doc(userId).collection('folders').doc(folderId).delete();
            } catch (e) {
                console.error("폴더 삭제 오류:", e);
                showError("폴더 삭제에 실패했습니다.");
            }
        }

        // 단어 목록 저장
        async function saveWordListToFirestore(listData) {
            if (!userId) return;
            try {
                await db.collection('users').doc(userId).collection('lists').doc(listData.id).set(listData);
            } catch (e) {
                console.error("단어 목록 저장 오류:", e);
                showError("단어 목록 저장에 실패했습니다.");
            }
        }
        
        // 단어 목록 삭제
        async function deleteWordListFromFirestore(listId) {
            if (!userId) return;
            try {
                await db.collection('users').doc(userId).collection('lists').doc(listId).delete();
            } catch (e) {
                console.error("단어 목록 삭제 오류:", e);
                showError("단어 목록 삭제에 실패했습니다.");
            }
        }

        // 개별 단어 저장
        async function saveManualWordToFirestore(manualWordItem) {
            if (!userId) return;
            try {
                await db.collection('users').doc(userId).collection('manualWords').doc(manualWordItem.id).set(manualWordItem);
            } catch (e) {
                console.error("개별 단어 저장 오류:", e);
                showError("단어 저장에 실패했습니다.");
            }
        }
        
        // 개별 단어 삭제
        async function deleteManualWordFromFirestore(manualWordId) {
            if (!userId) return;
            try {
                await db.collection('users').doc(userId).collection('manualWords').doc(manualWordId).delete();
            } catch (e) {
                console.error("개별 단어 삭제 오류:", e);
                showError("단어 삭제에 실패했습니다.");
            }
        }

        // 오답 노트 추가
        async function addWrongWordsToFirestore(newWrongWords) {
            if (!userId || !newWrongWords || newWrongWords.length === 0) return;

            newWrongWords.forEach(async newWord => {
                const docId = newWord.simplified; // simplified를 문서 ID로 사용 (중복 방지)
                const docRef = db.collection('users').doc(userId).collection('wrongWords').doc(docId);
                
                // Firestore에 추가
                try {
                    await docRef.set({
                        ...newWord,
                        id: docId, // Firestore ID와 일치
                        createdAt: new Date().toISOString()
                    });
                    
                    // 로컬 상태 업데이트
                    const exists = wrongWords.some(existingWord => existingWord.simplified === newWord.simplified);
                    if (!exists) {
                        wrongWords.push({...newWord, id: docId});
                    }
                } catch (e) {
                    console.error("오답 노트 추가 오류:", e);
                }
            });
        }
        
        // 오답 노트 삭제
        async function deleteWrongWordFromFirestore(simplified) {
             if (!userId) return;
            try {
                await db.collection('users').doc(userId).collection('wrongWords').doc(simplified).delete();
            } catch (e) {
                console.error("오답 삭제 오류:", e);
                showError("오답 단어 삭제에 실패했습니다.");
            }
        }
        
        // 오답 노트 전체 비우기
        async function clearAllWrongWordsFromFirestore() {
            if (!userId) return;
            try {
                const batch = db.batch();
                const snapshot = await db.collection('users').doc(userId).collection('wrongWords').get();
                snapshot.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });
                await batch.commit();
            } catch (e) {
                console.error("오답 노트 전체 비우기 오류:", e);
                showError("오답 노트 전체 비우기에 실패했습니다.");
            }
        }


        // 앱 초기화 및 인증 설정 (setupApp 대체)
        function setupAuthAndLoadData() {
            // 로딩 화면 표시
            contentContainer.innerHTML = renderLoadingScreen();
            
            // 인증 상태 감시
            auth.onAuthStateChanged(async (user) => {
                if (user) {
                    // 사용자 로그인 (익명 또는 기타)
                    userId = user.uid;
                    await loadUserDataFromFirestore(); // 데이터 로드
                    console.log("Firebase 로그인 완료. User ID:", userId);
                } else {
                    // 사용자 로그아웃 상태: 익명 로그인 시도
                    try {
                        const result = await auth.signInAnonymously();
                        userId = result.user.uid;
                        await loadUserDataFromFirestore(); 
                        console.log("Firebase 익명 로그인 성공. User ID:", userId);
                    } catch (error) {
                        console.error("익명 로그인 오류:", error);
                        showError("로그인 실패. 앱을 사용할 수 없습니다.");
                        isAppReady = true; 
                        renderApp();
                    }
                }
            });
        }

        // --- 폴더 관리 로직 (Firestore 연동) ---

        async function addFolder(name) {
            if (!name || name.trim() === '') {
                renderModal("입력 오류", "폴더 이름을 입력해야 합니다.");
                return;
            }
            const newFolder = {
                id: generateUniqueId(), 
                name: name.trim(),
                createdAt: new Date().toISOString()
            };
            
            await saveFolderToFirestore(newFolder);
            
            wordFolders.push(newFolder);
            selectedFolderId = newFolder.id;
            renderApp();
        }

        async function renameFolder(folderId, newName) {
            if (!newName || newName.trim() === '') {
                 renderModal("입력 오류", "새 폴더 이름을 입력해야 합니다.");
                return;
            }
            const folder = wordFolders.find(f => f.id === folderId);
            if (folder && newName.trim()) {
                folder.name = newName.trim();
                
                await saveFolderToFirestore(folder);
                renderApp();
            }
        }

        async function deleteFolder(folderId) {
            const defaultFolderId = wordFolders[0].id;
            const folderToDelete = wordFolders.find(f => f.id === folderId);
            
            if (folderId === defaultFolderId) {
                renderModal("삭제 불가", "기본 폴더는 삭제할 수 없습니다.");
                return;
            }

            renderModal(
                "폴더 삭제 확인", 
                `'${folderToDelete.name}' 폴더를 삭제하시겠습니까? 안에 있는 모든 단어 목록과 개별 단어는 '전체 단어장'으로 이동됩니다. 이 작업은 클라우드에서 삭제됩니다.`,
                async () => {
                    // 1. 단어 목록 (20개 그룹) 이동:
                    const listUpdatePromises = savedWordLists
                        .filter(list => list.folderId === folderId)
                        .map(list => {
                            list.folderId = defaultFolderId;
                            return saveWordListToFirestore(list);
                        });
                    
                    // 2. 개별 단어 이동:
                    const manualUpdatePromises = manualSavedWords
                        .filter(item => item.folderId === folderId)
                        .map(item => {
                            item.folderId = defaultFolderId;
                            return saveManualWordToFirestore(item);
                        });

                    await Promise.all([...listUpdatePromises, ...manualUpdatePromises]);

                    // 3. 폴더 삭제
                    await deleteFolderFromFirestore(folderId);
                    wordFolders = wordFolders.filter(f => f.id !== folderId);
                    
                    // 4. 선택 폴더 재설정
                    selectedFolderId = defaultFolderId;
                    renderApp();
                }
            );
        }

        // --- Local Storage Operations (Saved Lists) -> Firestore 변경 ---
        
        // ... (showFolderSelectionModal은 로컬 상태를 사용하므로 유지)
        
        async function saveWordList() {
            if (!generatedWords.length) {
                showError("저장할 단어 목록이 없습니다.");
                return;
            }

            showFolderSelectionModal().then(async targetFolderId => {
                if (!targetFolderId) return; 

                const listData = {
                    id: generateUniqueId(), 
                    folderId: targetFolderId, 
                    level: selectedLevel,
                    words: generatedWords,
                    createdAt: new Date().toLocaleDateString('ko-KR', { year: 'numeric', month: '2-digit', day: '2-digit' }),
                    wordCount: generatedWords.length,
                };
                
                await saveWordListToFirestore(listData);

                savedWordLists.push(listData);
                savedWordLists.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                
                selectedFolderId = targetFolderId;
                renderModal("저장 완료", `HSK ${selectedLevel}급 단어 ${generatedWords.length}개 목록이 클라우드에 저장되었습니다!`, () => {
                    currentView = 'lists';
                    isViewingWrongWords = false;
                    renderApp();
                });
            });
        }
        
        async function saveSingleWord(word) {
            showFolderSelectionModal().then(async targetFolderId => {
                if (!targetFolderId) return; 

                // 중복 확인 (simplified 기준)
                const isDuplicate = manualSavedWords.some(item => 
                    item.folderId === targetFolderId && item.word.simplified === word.simplified
                );

                if (isDuplicate) {
                    renderModal("추가 실패", `'${word.simplified}' 단어는 이미 이 폴더에 저장되어 있습니다.`);
                    return;
                }

                const newManualWord = {
                    id: generateUniqueId(),
                    folderId: targetFolderId,
                    word: word,
                    createdAt: new Date().toISOString()
                };
                
                await saveManualWordToFirestore(newManualWord);

                manualSavedWords.push(newManualWord);
                
                renderModal("추가 완료", `'${word.simplified}' 단어가 클라우드에 성공적으로 저장되었습니다.`);
            });
        }

        // 퀴즈 오답 저장 (Firestore 연동)
        function addWrongWords(newWrongWords) {
            if (!newWrongWords || newWrongWords.length === 0) return;
            // 로컬 상태와 Firestore에 동시 업데이트
            addWrongWordsToFirestore(newWrongWords); 
        }

        // --- 이하 Gemini API 및 UI 렌더링/리스너 함수들은 FireStore 함수를 호출하도록 변경되었습니다 ---
        
        // ... (중략: generateWords, fetchWithRetry, renderApp, showError, renderLoadingScreen, renderInputModal, renderModal, renderGeneratorView, renderWordCard, attachGeneratorListeners는 그대로 유지)

        // --- Quiz View ---

        function startQuiz(wordsToQuiz) {
            if (wordsToQuiz.length === 0) {
                showError("퀴즈를 시작할 단어 목록이 없습니다.");
                return;
            }
            quizWords = wordsToQuiz.sort(() => 0.5 - Math.random()); 
            currentQuestionIndex = 0;
            quizScore = 0;
            currentView = 'quiz';
            renderApp();
        }

        function generateQuizOptions(correctWord) {
             // 정답을 포함한 모든 단어의 뜻 목록을 만듭니다.
            const allWords = [
                ...generatedWords, 
                ...savedWordLists.flatMap(list => list.words || []), 
                ...wrongWords,
                ...manualSavedWords.map(item => item.word) 
            ];
            // simplified 기준으로 중복 제거
            const uniqueWords = allWords.filter((word, index, self) => 
                index === self.findIndex((t) => (t.simplified === word.simplified))
            );
            
            const options = [correctWord.korean_meaning];
            const incorrectWords = uniqueWords.filter(w => w.korean_meaning !== correctWord.korean_meaning);
            
            while (options.length < 4 && incorrectWords.length > 0) {
                const randomIndex = Math.floor(Math.random() * incorrectWords.length);
                const incorrectMeaning = incorrectWords.splice(randomIndex, 1)[0].korean_meaning;
                if (!options.includes(incorrectMeaning)) {
                    options.push(incorrectMeaning);
                }
            }

            return options.sort(() => 0.5 - Math.random());
        }

        async function handleAnswer(selectedMeaning) {
            const currentWord = quizWords[currentQuestionIndex];
            const correctMeaning = currentWord.korean_meaning;
            const isCorrect = selectedMeaning === correctMeaning;
            
            const selectedButton = document.querySelector(`[data-meaning="${selectedMeaning}"]`);
            
            if (isCorrect) {
                quizScore++;
                selectedButton.classList.add('bg-toss-green', 'text-white');
            } else {
                selectedButton.classList.add('bg-red-500', 'text-white');
                document.querySelector(`[data-meaning="${correctMeaning}"]`)?.classList.add('bg-hsk-red', 'text-white');
                
                addWrongWords([currentWord]); // Firebase 연동 함수 호출
            }

            document.querySelectorAll('.answer-button').forEach(btn => btn.disabled = true);

            setTimeout(() => {
                currentQuestionIndex++;
                renderApp();
            }, 1000); 
        }
        
        // ... (중략: renderQuizView, attachQuizListeners는 그대로 유지)


        // --- My Lists View (폴더 및 목록 렌더링) ---
        
        // ... (중략: renderFolderManagement, renderIndividualWordCard, renderWrongWordCard, renderListsView, renderStatsCard, renderSavedListCard는 그대로 유지)


        function attachListsListeners() {
            // --- 폴더 관리 리스너 ---
            document.getElementById('add-folder-button')?.addEventListener('click', () => {
                renderInputModal("새 폴더 이름 입력", "새 폴더", (folderName) => {
                    if (folderName) {
                        addFolder(folderName); // Firestore 연동
                    }
                });
            });

            document.querySelectorAll('.folder-pill').forEach(pill => {
                const folderId = pill.dataset.folderId;
                
                // 1-1. 폴더 선택 (필터링)
                pill.querySelector('.folder-name-display')?.addEventListener('click', () => {
                    isViewingWrongWords = false; 
                    selectedFolderId = folderId;
                    renderApp();
                });

                // 1-2. 폴더 이름 변경
                pill.querySelector('[data-action="rename"]')?.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    const currentFolder = wordFolders.find(f => f.id === folderId);
                    
                    if (currentFolder) {
                        renderInputModal(`'${currentFolder.name}' 이름 변경`, currentFolder.name, (newName) => {
                            if (newName) {
                                renameFolder(folderId, newName); // Firestore 연동
                            }
                        });
                    }
                });

                // 1-3. 폴더 삭제
                pill.querySelector('[data-action="delete"]')?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteFolder(folderId); // Firestore 연동
                });
            });

            // --- 오답 노트 / 저장 목록 토글 ---
            document.getElementById('toggle-saved-lists')?.addEventListener('click', () => {
                isViewingWrongWords = false;
                renderApp();
            });
            document.getElementById('toggle-wrong-words')?.addEventListener('click', () => {
                isViewingWrongWords = true;
                renderApp();
            });

            // --- 오답 노트/단어장 액션 ---
            document.getElementById('start-wrong-quiz')?.addEventListener('click', () => {
                if(wrongWords.length > 0) {
                    startQuiz(wrongWords);
                }
            });

            document.getElementById('clear-all-wrong-words')?.addEventListener('click', () => {
                renderModal("오답 노트 초기화", "오답 노트에 있는 모든 단어를 클라우드에서 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.", async () => {
                    await clearAllWrongWordsFromFirestore(); // Firestore 연동
                    wrongWords = [];
                    renderApp();
                });
            });

            // 오답 노트 개별 관리 및 저장 목록 삭제
            document.getElementById('word-list-display')?.addEventListener('click', async (e) => {
                const target = e.target.closest('button');
                
                if (!target) return;
                
                // 1. 개별 저장 단어 삭제 (delete-single)
                if (target.dataset.action === 'delete-single') {
                    const savedId = target.dataset.savedId;
                    const wordToDelete = manualSavedWords.find(item => item.id === savedId)?.word;
                    
                    if (wordToDelete) {
                        renderModal("단어 삭제 확인", `'${wordToDelete.simplified}' 단어를 클라우드에서 삭제하시겠습니까?`, async () => {
                            await deleteManualWordFromFirestore(savedId); // Firestore 연동
                            manualSavedWords = manualSavedWords.filter(item => item.id !== savedId);
                            renderApp();
                        });
                    }
                    return;
                }
                
                // 2. 오답 노트 개별 삭제 (delete-wrong)
                if (target.dataset.action === 'delete-wrong') {
                    const index = parseInt(target.dataset.wordIndex);
                    const wordToDelete = wrongWords[index];
                    
                    renderModal("오답 삭제 확인", `'${wordToDelete.simplified}' 단어를 오답 노트에서 삭제하시겠습니까? (클라우드에서 삭제)`, async () => {
                        await deleteWrongWordFromFirestore(wordToDelete.simplified); // Firestore 연동 (simplified를 ID로 사용)
                        wrongWords.splice(index, 1);
                        renderApp();
                    });
                    return;
                }
                
                // 3. 저장된 목록 개별 삭제 (delete-list)
                if (target.dataset.action === 'delete-list') {
                    const listId = target.dataset.listId;
                    const listToDelete = savedWordLists.find(l => l.id === listId);

                    renderModal("단어 목록 삭제", `'HSK ${listToDelete.level}급 단어 목록'을 클라우드에서 삭제하시겠습니까?`, async () => {
                        await deleteWordListFromFirestore(listId); // Firestore 연동
                        savedWordLists = savedWordLists.filter(l => l.id !== listId);
                        renderApp();
                    });
                    return;
                }
                
                // 4. 저장된 목록 보기/퀴즈 (load)
                const listId = target.dataset.listId;
                const action = target.dataset.action;
                const list = savedWordLists.find(l => l.id === listId);

                if (!list || action !== 'load' && action !== 'quiz') return;

                if (action === 'load') {
                    selectedLevel = list.level;
                    generatedWords = list.words;
                    currentView = 'generator';
                    renderApp();
                    renderModal("단어장 불러오기 완료", `HSK ${list.level}급 단어 ${list.wordCount}개가 생성기 목록에 로드되었습니다.`);
                }
            });
            
            // 상세 정보 토글 리스너
            document.querySelectorAll('#word-list-display .word-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    const actionButton = e.target.closest('button[data-action]');
                    if (actionButton) return; 

                    const details = card.querySelector('.word-details');
                    const icon = card.querySelector('i.fa-chevron-down');
                    if (details) {
                        details.classList.toggle('hidden');
                        if(icon) icon.classList.toggle('rotate-180');
                    }
                });
            });
        }

        // ------------------------------------------
        // 🏁 Initialization (기존 window.onload 대체)
        // ------------------------------------------

        window.onload = () => {
            tabGenerator.addEventListener('click', () => {
                currentView = 'generator';
                renderApp();
            });
            tabLists.addEventListener('click', () => {
                currentView = 'lists';
                isViewingWrongWords = false; 
                renderApp();
            });

            setupAuthAndLoadData(); // Firebase 인증 및 데이터 로드 시작
        };
        
        // ** (generateWords, fetchWithRetry 등 GEMINI API 관련 함수는 길어서 중략했으나, 기존 코드에서 그대로 유지됩니다.) **
        
        // --- (중략된 함수들을 위해 더미 함수 정의) ---
        async function fetchWithRetry() { /* 구현 생략 */ }
        async function generateWords() { /* 구현 생략 */ }
        function showFolderSelectionModal() { 
            return new Promise(resolve => resolve(wordFolders[0]?.id)); 
        }
        function renderWordCard(word, index) { /* 구현 생략 */ return `<div>${word.simplified}</div>`; }
        function attachGeneratorListeners() { /* 구현 생략 */ }
        // ... (renderApp, renderGeneratorView 등 다른 UI 함수들도 기존 코드가 유지됩니다)
        
    </script>
</head>
<body>
</body>
</html>
